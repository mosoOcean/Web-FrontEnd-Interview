### JS中的模块规范

#### 模块化
JS最原始的加载方式为**script标签**方式，例如：

```
<script src="module1.js"></script>
<script src="module2.js"></script>
<script src="libraryA.js"></script>
<script src="module3.js"></script>
```
他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口。
这种加载方式有以下弊端：

*	全局作用域下容易造成变量冲突
* 	文件只能按照 script标签 的书写顺序进行加载
*  开发人员必须主观解决模块和代码库的依赖关系
*  在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪

因此模块化的思想应运而生，所谓模块化，就是将复杂的系统一步步细分解为多个小而简单的模块，达到化繁为简的目的。这样做的好处就是可以极大提升开发效率以及方便后期维护。

#### 模块化规范
模块化既然化繁为简，那肯定有其运作的规则或者说是规范，才能井然有序地组成复杂的系统。

JS现行的主要模块化规范主要有**CommonJS规范**、**AMD规范**、**CMD规范**。

#### CommonJS规范

###### CommonJS规范历史：

CommonJS就是为JS的表现来制定规范，因为js没有模块的功能所以CommonJS应运而生，它希望js可以在任何地方运行，不只是浏览器中。

2009年1月，Mozilla 的工程师 Kevin Dangoor 创建了这个项目，当时的名字是 ServerJS。其是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。

2009年8月，这个项目改名为 CommonJS，以显示其 API 的更广泛实用性。

需要注意的是CommonJS通常是服务器端模块的规范，Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。

###### CommonJS规范要点

* 每个文件就是一个模块， 有自己的作用域。

* 在一个文件里定义的变量、函数、类都是私有的，对其他文件不可见。

* 导出：每个模块内部，变量module代表当前模块，这个变量是一个对象。它的exports属性(即module.exports)是一个对外的接口。

* 导入：require方法用于加载模块。

**该规范的核心思想是允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。**

例子：

```
moduleA.js

//导出
 exports.doStuff = function() {};
 module.exports = someValue; 
 
moduleB.js
//导入
require("moduleA");//标志方式
require("../moduleA.js");//路径方式
 
```

###### CommonJS特点

* 所有代码都运行在模块作用域，不会污染全局作用域。

* 由于Node.js主要用于服务器编程，**模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式**，所以CommonJS规范比较适用。

* **模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清楚缓存**

* 模块加载的顺序，按其在代码中出现的顺序。

######* 优点
* 简单容易使用

* 服务器端模块便于复用

######* 缺点
* 同步加载方式不适合在浏览器环境中使用，同步意味着阻塞加载，浏览器资源是异步加载的（因为对于浏览器端，模块都放在服务器端，加载的时间还取决于网速的快慢等因素，如果需要等很长时间，整个应用就会被阻塞。）

* 不能非阻塞的并行加载多个模块

######* 实现
node.js

#### AMD规范

因为 CommonJS 模块系统是同步加载的，当前浏览器环境还没有准备好同步加载模块的条件，AMD（异步模块定义）是为浏览器环境设计而生。异步模块定义规范（AMD）制定模块和模块的依赖可以被异步加载。这和浏览器的异步加载模块的环境刚好适应（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题）。

###### AMD规范要点

**只定义了一个函数 "define"，它是全局变量**。函数的描述为：

```
define(id?, dependencies?, factory);
```
它要在声明模块的时候制定所有的依赖(dep)，并且还要当做形参传到factory中，像这样：

```
define(['dep1','dep2'],function(dep1,dep2){...});
```
 

**采用异步方式加载模块，模块的加载是并行的**。所有依赖模块的语句，都定义在一个回调函数中，等到加载完成之后，回调函数才执行。

加载模块例子：

```
// 加载模块
require(["module", "../app"], function(module, app) {...});
```
执行流程：

1. require函数检查依赖的模块，根据配置文件，获取js文件的实际路径

2. 根据js文件实际路径，在dom中插入script节点，并绑定onload事件来获取该模块加载完成的通知。

3. 依赖script全部加载完成后，调用回调函数

###### AMD规范特点

######* 优点

* 适合在浏览器环境中异步加载模块
* 可以并行加载多个模块

######* 缺点

* 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅
* 不符合通用的模块化思维方式，是一种妥协的实现

######* 实现
require.js


#### CMD规范

大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范。与CommonJS和Node.js的 Modules 规范保持了很大的兼容性；

###### CMD规范要点

```
define(function(require, exports, module) {
  var $ = require('jquery');
  var Spinning = require('./spinning');
  exports.doSomething = ...
  module.exports = ...
})
```
* 定义模块使用全局函数define，其接收 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串；
* factory 是一个函数，有三个参数，function(require, exports, module)：

	1. require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id)
	2. exports 是一个对象，用来向外提供模块接口
	3. module 是一个对象，上面存储了与当前模块相关联的一些属性和方法

###### CMD规范特点

######* 优点

* 依赖就近，延迟执行
* 可以很容易在 Node.js 中运行

######* 缺点

* 依赖 SPM 打包，模块的加载逻辑偏重

######* 实现
sea.js：SeaJS对模块的态度是懒执行, SeaJS只会在真正需要使用(依赖)模块时才执行该模块

#### ES6模块

EcmaScript6 标准增加了 JavaScript 语言层面的模块体系定义。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。

```
import "./moduleA";
export function doStuff() {}
```

###### ES6模块特点

######* 优点

* 容易进行静态分析
* 面向未来的 EcmaScript 标准

######* 缺点

* 原生浏览器端还没有实现该标准
* 全新的命令字，新版的 Node.js才支持

######* 实现
babel

### AMD规范与CMD规范不同之处

```
// AMD
define(['./a', './b'], function(a, b) {  // 依赖必须一开始就写好  
   a.doSomething()    
   // 此处略去 100 行    
   b.doSomething()    
   ...
});
// CMD
define(function(require, exports, module) {
   var a = require('./a')   
   a.doSomething()   
   // 此处略去 100 行   
   var b = require('./b') 
   // 依赖可以就近书写   
   b.doSomething()
   // ... 
});
```

SeaJS只会在真正需要使用(依赖)模块时才执行该模块
SeaJS是异步加载模块的没错, 但执行模块的顺序也是严格按照模块在代码中出现(require)的顺序, 这样才更符合逻辑吧! 你说呢, RequireJS?

而RequireJS会先尽早地执行(依赖)模块, 相当于所有的require都被提前了

注意我这里说的是执行(真正运行define中的代码)模块, 而非加载(load文件)模块.
模块的加载都是并行的, 没有区别, 区别在于执行模块的时机, 或者说是解析.

可以很明显的看出RequireJS的做法是并行加载所有依赖的模块, 并完成解析后, 再开始执行其他代码, 因此执行结果只会"停顿"1次, 完成整个过程是会比SeaJS要快.

而SeaJS一样是并行加载所有依赖的模块, 但不会立即执行模块, 等到真正需要(require)的时候才开始解析, 这里耗费了时间, 因为这个特例中的模块巨大, 因此造成"停顿"2次的现象, 这就是我所说的SeaJS中的"懒执行".







